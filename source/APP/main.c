#include "DCBX_Test_CEE.h"
#include "DCBX_Test_IEEE.h"
#include "DCBX_Analyze.h"
#include "mctp.h"
#include "sha256.h"
#include "main.h"


u8 g_dcbx_intel_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x81, 0x00, 0xe0, 0x09,        //dcbx-intel.pcap
                0x88, 0xcc, 0x02, 0x07, 0x04, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x04, 0x07, 0x07, 0x45, 0x74,
                0x68, 0x31, 0x2f, 0x33, 0x06, 0x02, 0x00, 0x78, 0x08, 0x0b, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e,
                0x65, 0x74, 0x31, 0x2f, 0x33, 0x0a, 0x0c, 0x4e, 0x35, 0x4b, 0x2d, 0x35, 0x2d, 0x4c, 0x61, 0x62,
                0x33, 0x2d, 0x33, 0x0c, 0x95, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x4e, 0x65, 0x78, 0x75, 0x73,
                0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65,
                0x6d, 0x20, 0x28, 0x4e, 0x58, 0x2d, 0x4f, 0x53, 0x29, 0x20, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,
                0x72, 0x65, 0x0a, 0x54, 0x41, 0x43, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x3a, 0x20,
                0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x63, 0x69, 0x73, 0x63, 0x6f,
                0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x61, 0x63, 0x0a, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67,
                0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x32, 0x2d, 0x32, 0x30, 0x31, 0x32,
                0x2c, 0x20, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x2c,
                0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x73,
                0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x0e, 0x04, 0x00, 0x04, 0x00, 0x04,
                0x10, 0x0c, 0x05, 0x01, 0xc0, 0xa8, 0x00, 0x3a, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x37,
                0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
                0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x08, 0x08, 0x08, 0x0a, 0x00, 0x00, 0x80, 0x00, 0x89, 0x06,
                0x00, 0x1b, 0x21, 0x08, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x32, 0x32,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xfe, 0x05, 0x00, 0x01, 0x42, 0x01, 0x01, 0xfe, 0x14,
                0x00, 0x01, 0x42, 0x02, 0x05, 0xdc, 0x05, 0xdc, 0x05, 0xdc, 0x08, 0x6e, 0x05, 0xdc, 0x05, 0xdc,
                0x05, 0xdc, 0x05, 0xdc, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x32, 0x00, 0x00
                };            
u8 g_dcbx_sample_capture_1_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_1.pcap
            0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
            0x28, 0xfe, 0x3d, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x64, 0x03, 0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x00, 0x08, 0x08, 0x10,
            0x00, 0x00, 0x80, 0x00, 0xc3, 0x51, 0x01, 0x1b, 0x21, 0x02, 0xc3, 0x50, 0x01, 0x1b, 0x21, 0x04,
            0x0c, 0x58, 0x4a, 0x75, 0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,
            0x6b, 0x73, 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30,
            0x73, 0x20, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33,
            0x58, 0x35, 0x30, 0x2e, 0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65,
            0x3a, 0x20, 0x32, 0x30, 0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a,
            0x33, 0x32, 0x3a, 0x30, 0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14,
            0x08, 0x0b, 0x78, 0x65, 0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00,
            0x12, 0x0f, 0x01, 0x01, 0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00,
            0x00, 0x00, 0x00, 0xfe, 0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2,
            0x01, 0x00, 0x00, 0xfe, 0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61,
            0x75, 0x6c, 0x74, 0x00, 0x00
            };        
u8 g_dcbx_sample_capture_2_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_2.pcap      
                0x04, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x04, 0x07, 0x03, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0,
                0x06, 0x02, 0x00, 0x78, 0xfe, 0x43, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x04, 0x11, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x11, 0x1f,
                0x19, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0xc0, 0x00, 0x08,
                0x08, 0x08, 0x16, 0x00, 0x00, 0xe0, 0x00, 0x89, 0x06, 0x01, 0x1b, 0x21, 0x08, 0x0c, 0xbc, 0x01,
                0x1b, 0x21, 0x08, 0x89, 0x14, 0x00, 0x1b, 0x21, 0x08, 0x00, 0x00
                };  

u8 g_ieee_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,           //ieee.pcap
                0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
                0x28, 0xfe, 0x19, 0x00, 0x80, 0xc2, 0x09, 0x03, 0x77, 0x76, 0x77, 0x76, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x64, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x19, 0x00, 0x80,
                0xc2, 0x0a, 0x03, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x02,
                0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x0b, 0x08, 0x00, 0xfe,
                0x0b, 0x00, 0x80, 0xc2, 0x0c, 0x00, 0x24, 0xc3, 0x51, 0x44, 0xc3, 0x50, 0x0c, 0x58, 0x4a, 0x75,
                0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x2c, 0x20,
                0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30, 0x73, 0x20, 0x2c, 0x20,
                0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33, 0x58, 0x35, 0x30, 0x2e,
                0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x32, 0x30,
                0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a, 0x33, 0x32, 0x3a, 0x30,
                0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14, 0x08, 0x0b, 0x78, 0x65,
                0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x01, 0x01,
                0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0xfe,
                0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x00, 0xfe,
                0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x00,
                0x00
                };

typedef struct {
    u8 sync_config;
    u8 sync_config_sup;
    u8 event_class_cnt;
    u8 eventclass[0];
} pldm_event_msg_sup_rsp_dat_t;

u8 gs_buf[128] = {244};

u8 gs_sumbus_pkt0[] = {                         /* Clear Initial State 0x00 */
    0x92, 0x0f, 0x1a, 0x21,
    0x01, 0x0A, 0x08, 0xfb,
    0x02,
    0x00, 0x01, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,                   /* checksum */
    0x40                                        /* pec */
};

#pragma pack(1)

typedef struct {
	u16 entity_type;
	u16 entity_instance_num;
	u16 entity_container_id;
} pldm_entity;

typedef struct {
	u32 record_handle;
	u8 version;
	u8 type;
	u16 record_change_num;
	u16 length;
}pldm_pdr_hdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u16 sensor_id;
    pldm_entity container;
    u8 sensor_init;
    bool sensor_auxiliary_names_pdr;
    u8 base_unit;
    s8 unit_modifier;
    u8 rate_unit;
    u8 base_oem_unit_handle;
    u8 aux_unit;
    u8 aux_unit_modifier;
    u8 aux_rate_unit;
    u8 rel;
    u8 aux_oem_unit_handle;
    bool is_linear;
    u8 sensor_data_size;
    u32 resolution;
    u32 offset;
    u16 accuracy;
    u8 plus_tolerace;
    u8 minus_tolerance;
    u8 hysteresis;
    u8 supported_thresholds;
    u8 threshold_and_hysteresis_volatility;
    u32 state_transition_interval;
    u32 update_interval;
    u8 max_readable;
    u8 min_readable;
    u8 range_field_format;
    u8 range_field_support;
    u16 nominal_value;
	u16 normal_max;
	u16 normal_min;
	u16 warning_high;
	u16 warning_low;
	u16 critical_high;
	u16 critical_low;
	u16 fatal_high;
	u16 fatal_low;
} pldm_thermal_sensor_pdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u8 validity;
    u8 tid;
    u16 container_id;
    u8 terminus_locator_type;
	u8 terminus_locator_value_size;
    u8 eid;
} pldm_terminus_locator_pdr;

typedef struct {
    u8 sensor_type;
    u8 composite_state;
} pldm_composite_sensor_attr;

typedef struct {
    pldm_entity container;
    u16 terminus_handle;
    u16 sensor_id;
    u8 composite_sensor_cnt;
    pldm_composite_sensor_attr sensors[3];
} pldm_somposite_state_sensor_pdr;

typedef struct {
	u16 container_id;
	u8 association_type;
	pldm_entity container;
	u8 num_children;
	pldm_entity children[3];
} pldm_pdr_entity_association;

typedef struct {
    u8 tid;
    u16 event_id;
    u32 next_data_transfer_handle;
    u8 transfer_flag;
    u8 event_class;
    u32 event_datasize;                     /* Size in byes of eventData */
    u8 *event_data;
    u32 event_data_integrity_checksum;
} pldm_poll_for_platform_event_msg_rsp_dat_t;

#pragma pack()

u8 a[] = {1,2,3,4,5,6};
u8 b[] = {1,2,3,4,5};
u8 c[] = {1,2,3,4};

u8 *data[] = {
    a,b,c
};
u8 erwei[2][2] = {
    [0] = {
        1,2
    },
    [1] = {
        1,2
    },
};

void printf_one(int a)
{
    printf("%d\n", a);
}

void test(void)
{
    int num = 1000;
    printf_one(num);
}

typedef void (*func)(void);

void ab(void)
{
    printf("hhhhhh\n");
}

int main(int argc, char * argv [])
{
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // pldm_event_msg_sup_rsp_dat_t *aa = (pldm_event_msg_sup_rsp_dat_t *)gs_buf;
    // u32 c = (u32)gs_buf;
    // u32 *a = (u32 *)(c);
    // u8 b[8] = {0};

    // ((u32 *)b)[0] = 0x12345678;
    // u8 pec = crc16_i2c_smbus(0, gs_sumbus_pkt0, gs_sumbus_pkt0[2] + 3);
    // pldm_poll_for_platform_event_msg_rsp_dat_t *a = NULL;
    // printf("0x%x\n", pec);
    // printf("%x\n", *((u32 *)(&b[0])));
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // u8 present_state = 10;
    // u8 *a = &present_state;
    // printf("%d", a[0]);
    // printf("%d\n", test());
    // unsigned char in[] = "hello world";
	// unsigned char buff[32];//必须带unsigned ,sha256消息摘要输出为256位,即32字节
	// memset(buff,0,32);
	// puts("start sha256 hash \n");
	// sha256(in,strlen(in),buff);
	// printf("\nThe sha256 hash is :\n");
    // 	for(int i=0;i<32;i++)
	// {
 
	// 	printf("%02x",buff[i]);	
	// }
	// puts("\n end sha256 hash \n");
    // rsa_test();
    // u8 xzxz[] = {0x1c, 0x1c, 0x1c, 0x1c};
    // printf("%x", crc32_pldm(xzxz, 4));
    // u32 notify_buf[] = {
    //     0xa7006003, \
    //     0x00000000, \
    //     0x0092e004, \
    //     0x1000017f, \
    //     0xb41a0000, \
    //     0xc8080001, \
    //     0x000d8000, \
    //     0x00000000
    // };
    // mctp_hdr_t *mctp_hdr = (mctp_hdr_t *)&notify_buf[5];
    // printf("src_eid : 0x%02x\n", mctp_hdr->dest_eid);
    func cmd = ab;
    printf("%d\n", cmd == ab);
	return 0;
}



