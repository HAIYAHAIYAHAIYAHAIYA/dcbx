#include "DCBX_Test_CEE.h"
#include "DCBX_Test_IEEE.h"
#include "DCBX_Analyze.h"
#include "mctp.h"
#include "sha256.h"
#include "cJSON.h"
#include "pldm_cjson.h"
#include "pldm_bej_resolve.h"
#include "pldm_fw_update.h"
#include "main.h"


u8 g_dcbx_intel_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x81, 0x00, 0xe0, 0x09,        //dcbx-intel.pcap
                0x88, 0xcc, 0x02, 0x07, 0x04, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x04, 0x07, 0x07, 0x45, 0x74,
                0x68, 0x31, 0x2f, 0x33, 0x06, 0x02, 0x00, 0x78, 0x08, 0x0b, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e,
                0x65, 0x74, 0x31, 0x2f, 0x33, 0x0a, 0x0c, 0x4e, 0x35, 0x4b, 0x2d, 0x35, 0x2d, 0x4c, 0x61, 0x62,
                0x33, 0x2d, 0x33, 0x0c, 0x95, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x4e, 0x65, 0x78, 0x75, 0x73,
                0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65,
                0x6d, 0x20, 0x28, 0x4e, 0x58, 0x2d, 0x4f, 0x53, 0x29, 0x20, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,
                0x72, 0x65, 0x0a, 0x54, 0x41, 0x43, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x3a, 0x20,
                0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x63, 0x69, 0x73, 0x63, 0x6f,
                0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x61, 0x63, 0x0a, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67,
                0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x32, 0x2d, 0x32, 0x30, 0x31, 0x32,
                0x2c, 0x20, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x2c,
                0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x73,
                0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x0e, 0x04, 0x00, 0x04, 0x00, 0x04,
                0x10, 0x0c, 0x05, 0x01, 0xc0, 0xa8, 0x00, 0x3a, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x37,
                0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
                0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x08, 0x08, 0x08, 0x0a, 0x00, 0x00, 0x80, 0x00, 0x89, 0x06,
                0x00, 0x1b, 0x21, 0x08, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x32, 0x32,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xfe, 0x05, 0x00, 0x01, 0x42, 0x01, 0x01, 0xfe, 0x14,
                0x00, 0x01, 0x42, 0x02, 0x05, 0xdc, 0x05, 0xdc, 0x05, 0xdc, 0x08, 0x6e, 0x05, 0xdc, 0x05, 0xdc,
                0x05, 0xdc, 0x05, 0xdc, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x32, 0x00, 0x00
                };            
u8 g_dcbx_sample_capture_1_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_1.pcap
            0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
            0x28, 0xfe, 0x3d, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x64, 0x03, 0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x00, 0x08, 0x08, 0x10,
            0x00, 0x00, 0x80, 0x00, 0xc3, 0x51, 0x01, 0x1b, 0x21, 0x02, 0xc3, 0x50, 0x01, 0x1b, 0x21, 0x04,
            0x0c, 0x58, 0x4a, 0x75, 0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,
            0x6b, 0x73, 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30,
            0x73, 0x20, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33,
            0x58, 0x35, 0x30, 0x2e, 0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65,
            0x3a, 0x20, 0x32, 0x30, 0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a,
            0x33, 0x32, 0x3a, 0x30, 0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14,
            0x08, 0x0b, 0x78, 0x65, 0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00,
            0x12, 0x0f, 0x01, 0x01, 0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00,
            0x00, 0x00, 0x00, 0xfe, 0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2,
            0x01, 0x00, 0x00, 0xfe, 0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61,
            0x75, 0x6c, 0x74, 0x00, 0x00
            };        
u8 g_dcbx_sample_capture_2_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_2.pcap      
                0x04, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x04, 0x07, 0x03, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0,
                0x06, 0x02, 0x00, 0x78, 0xfe, 0x43, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x04, 0x11, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x11, 0x1f,
                0x19, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0xc0, 0x00, 0x08,
                0x08, 0x08, 0x16, 0x00, 0x00, 0xe0, 0x00, 0x89, 0x06, 0x01, 0x1b, 0x21, 0x08, 0x0c, 0xbc, 0x01,
                0x1b, 0x21, 0x08, 0x89, 0x14, 0x00, 0x1b, 0x21, 0x08, 0x00, 0x00
                };  

u8 g_ieee_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,           //ieee.pcap
                0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
                0x28, 0xfe, 0x19, 0x00, 0x80, 0xc2, 0x09, 0x03, 0x77, 0x76, 0x77, 0x76, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x64, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x19, 0x00, 0x80,
                0xc2, 0x0a, 0x03, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x02,
                0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x0b, 0x08, 0x00, 0xfe,
                0x0b, 0x00, 0x80, 0xc2, 0x0c, 0x00, 0x24, 0xc3, 0x51, 0x44, 0xc3, 0x50, 0x0c, 0x58, 0x4a, 0x75,
                0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x2c, 0x20,
                0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30, 0x73, 0x20, 0x2c, 0x20,
                0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33, 0x58, 0x35, 0x30, 0x2e,
                0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x32, 0x30,
                0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a, 0x33, 0x32, 0x3a, 0x30,
                0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14, 0x08, 0x0b, 0x78, 0x65,
                0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x01, 0x01,
                0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0xfe,
                0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x00, 0xfe,
                0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x00,
                0x00
                };

typedef struct {
    u8 sync_config;
    u8 sync_config_sup;
    u8 event_class_cnt;
    u8 eventclass[0];
} pldm_event_msg_sup_rsp_dat_t;

u8 gs_buf[128] = {244};

u8 gs_sumbus_pkt0[] = {                         /* Clear Initial State 0x00 */
    0x92, 0x0f, 0x1a, 0x21,
    0x01, 0x0A, 0x08, 0xfb,
    0x02,
    0x00, 0x01, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,                   /* checksum */
    0x40                                        /* pec */
};

#pragma pack(1)

typedef struct {
	u16 entity_type;
	u16 entity_instance_num;
	u16 entity_container_id;
} pldm_entity;

typedef struct {
	u32 record_handle;
	u8 version;
	u8 type;
	u16 record_change_num;
	u16 length;
}pldm_pdr_hdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u16 sensor_id;
    pldm_entity container;
    u8 sensor_init;
    bool sensor_auxiliary_names_pdr;
    u8 base_unit;
    s8 unit_modifier;
    u8 rate_unit;
    u8 base_oem_unit_handle;
    u8 aux_unit;
    u8 aux_unit_modifier;
    u8 aux_rate_unit;
    u8 rel;
    u8 aux_oem_unit_handle;
    bool is_linear;
    u8 sensor_data_size;
    u32 resolution;
    u32 offset;
    u16 accuracy;
    u8 plus_tolerace;
    u8 minus_tolerance;
    u8 hysteresis;
    u8 supported_thresholds;
    u8 threshold_and_hysteresis_volatility;
    u32 state_transition_interval;
    u32 update_interval;
    u8 max_readable;
    u8 min_readable;
    u8 range_field_format;
    u8 range_field_support;
    u16 nominal_value;
	u16 normal_max;
	u16 normal_min;
	u16 warning_high;
	u16 warning_low;
	u16 critical_high;
	u16 critical_low;
	u16 fatal_high;
	u16 fatal_low;
} pldm_thermal_sensor_pdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u8 validity;
    u8 tid;
    u16 container_id;
    u8 terminus_locator_type;
	u8 terminus_locator_value_size;
    u8 eid;
} pldm_terminus_locator_pdr;

typedef struct {
    u8 sensor_type;
    u8 composite_state;
} pldm_composite_sensor_attr;

typedef struct {
    pldm_entity container;
    u16 terminus_handle;
    u16 sensor_id;
    u8 composite_sensor_cnt;
    pldm_composite_sensor_attr sensors[3];
} pldm_somposite_state_sensor_pdr;

typedef struct {
	u16 container_id;
	u8 association_type;
	pldm_entity container;
	u8 num_children;
	pldm_entity children[3];
} pldm_pdr_entity_association;

typedef struct {
    u8 tid;
    u16 event_id;
    u32 next_data_transfer_handle;
    u8 transfer_flag;
    u8 event_class;
    u32 event_datasize;                     /* Size in byes of eventData */
    u8 *event_data;
    u32 event_data_integrity_checksum;
} pldm_poll_for_platform_event_msg_rsp_dat_t;

#pragma pack()

extern u8 bej_buf[];
extern u8 dict0[];
extern u8 dict1[];
extern u8 dict_test[];
extern u8 *json_buf;
extern u8 json_test[];
// extern cJSON *cjson_test;

void printf_cjson(cJSON *node)
{
    if (!node) return;
    printf("name : %s\n", node->string);
    printf_cjson(node->child);
    printf_cjson(node->next);
}

#pragma pack(1)

typedef struct {
    u16 len;
    u32 dict_sign;
    u8 data[0];
} pldm_redfish_dict_fmt_t;
typedef struct {
    u32 resource_id;
    u16 schema_class;
    u16 offset;
} dict_off_id_t;

typedef struct {
    u16 total_len;
    u16 num_of_dict;
    dict_off_id_t dict[0];
} dict_hdr_t;

#pragma pack()
int main(int argc, char * argv [])
{
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // pldm_event_msg_sup_rsp_dat_t *aa = (pldm_event_msg_sup_rsp_dat_t *)gs_buf;
    // u32 c = (u32)gs_buf;
    // u32 *a = (u32 *)(c);
    // u8 b[8] = {0};

    // ((u32 *)b)[0] = 0x12345678;
    // u8 pec = crc16_i2c_smbus(0, gs_sumbus_pkt0, gs_sumbus_pkt0[2] + 3);
    // pldm_poll_for_platform_event_msg_rsp_dat_t *a = NULL;
    // printf("0x%x\n", pec);
    // printf("%x\n", *((u32 *)(&b[0])));
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // u8 present_state = 10;
    // u8 *a = &present_state;
    // printf("%d", a[0]);
    // printf("%d\n", test());
    // unsigned char in[] = "hello world";
	// unsigned char buff[32];//必须带unsigned ,sha256消息摘要输出为256位,即32字节
	// memset(buff,0,32);
	// puts("start sha256 hash \n");
	// sha256(in,strlen(in),buff);
	// printf("\nThe sha256 hash is :\n");
    // 	for(int i=0;i<32;i++)
	// {
 
	// 	printf("%02x",buff[i]);	
	// }
	// puts("\n end sha256 hash \n");
    // rsa_test();
    // u8 xzxz[] = {0x1c, 0x1c, 0x1c, 0x1c};
    // printf("%x", crc32_pldm(xzxz, 4));
    // u32 notify_buf[] = {
    //     0xa7006003, \
    //     0x00000000, \
    //     0x0092e004, \
    //     0x1000017f, \
    //     0xb41a0000, \
    //     0xc8080001, \
    //     0x000d8000, \
    //     0x00000000
    // };
    // mctp_hdr_t *mctp_hdr = (mctp_hdr_t *)&notify_buf[5];
    // printf("src_eid : 0x%02x\n", mctp_hdr->dest_eid);
    // pldm_redfish_dictionary_format_t *dict_ptr = (pldm_redfish_dictionary_format_t *)dict0;
    // for (u8 i = 0; i < dict_ptr->entry_cnt; i++) {
    //     printf("fmt : 0x%02x\n", dict_ptr->entry[i].format);
    // }
    // cJSON *fmt_err = NULL;
    // cJSON *dummy = NULL;
    // pldm_bej_init();
    // pldm_cjson_test();
    // printf("total len : %d\n", pldm_bej_decode(bej_buf, dict0, &(dict_ptr->entry[0]), dict_ptr->entry_cnt, cjson_test));
    // char *str = cJSON_Print(cjson_test);
    // printf("%s\n", str);
    // dummy = cJSON_GetObjectItem(cjson_test, "DummySimple");
    // fmt_err = cJSON_GetObjectItem(dummy, "fmt_err");
    // printf("%s\n", fmt_err->valuestring);
    // cJSON_Delete(cjson_test);
    // pldm_bej_encode(json_buf, dict);
    // pldm_cjson_test();

    // cJSON *tmp = cJSON_Parse(json_buf);
    // char *str = cJSON_Print(tmp);
    // printf("%s\n", str);
    // printf_cjson(tmp);
    // cJSON_Delete(tmp);

    // cJSON *ptr = cJSON_Parse((char *)json_test);
    // char *str = cJSON_Print(ptr);
    // printf("%s\n", str);
    // FILE *pd = NULL;
    // u8 b[9000];
    // 读取二进制文件
    // 文件名："test.bin",  访问方式："rb"
    // pd = fopen("dict_data.bin", "rb");
    // 数据块首地址: "&b", 元素大小: "sizeof(unsigned __int8)",  元素个数: "10",  文件指针："pd"
    // fread(&b, sizeof(u8), 1024, pd);
    // fclose(pd);
    // pldm_redfish_dictionary_format_t *dict = (pldm_redfish_dictionary_format_t *)b;
    // u16 len = dict->dictionary_size;
    // printf("%d\n", len);
    // pd = fopen("./dict/PCIeDevice_v1.bin", "rb");
    // // 数据块首地址: "&b", 元素大小: "sizeof(unsigned __int8)",  元素个数: "10",  文件指针："pd"
    // fread(&b, sizeof(u8), len, pd);
    // fclose(pd);
    // dict_hdr_t *dicts = (dict_hdr_t *)b;
    // printf("total : %d\n", dicts->total_len);
    // printf("num : %d\n", dicts->num_of_dict);
    // pldm_redfish_dict_fmt_t *dict_fmt = (pldm_redfish_dict_fmt_t *)&b[dicts->dict[0].offset];
    // printf("%#x\n", dict_fmt->dict_sign);
    // printf("%d\n", dict_fmt->len);
    // for (u8 i = 0; i < dicts->num_of_dict; i++) {
    //     printf("id : %d\n", dicts->dict[i].resource_id);
    //     printf("off : %d\n", dicts->dict[i].offset);
    // }
    // printf("%08x\n", ~crc32_pldm(b, len));
    // printf("%08x\n", ~0xa4fc415f);
    // for (u8 i = 0; i < 8; i++) {
    //     printf("%02x \n", b[i]);
    // }
    pldm_fwup_verify_pkt_data_test();
	return 0;
}



