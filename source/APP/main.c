#include "DCBX_Test_CEE.h"
#include "DCBX_Test_IEEE.h"
#include "DCBX_Analyze.h"
#include "mctp.h"
#include "sha256.h"
#include "main.h"


u8 g_dcbx_intel_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x81, 0x00, 0xe0, 0x09,        //dcbx-intel.pcap
                0x88, 0xcc, 0x02, 0x07, 0x04, 0x00, 0x05, 0x73, 0xf3, 0x4d, 0x4a, 0x04, 0x07, 0x07, 0x45, 0x74,
                0x68, 0x31, 0x2f, 0x33, 0x06, 0x02, 0x00, 0x78, 0x08, 0x0b, 0x45, 0x74, 0x68, 0x65, 0x72, 0x6e,
                0x65, 0x74, 0x31, 0x2f, 0x33, 0x0a, 0x0c, 0x4e, 0x35, 0x4b, 0x2d, 0x35, 0x2d, 0x4c, 0x61, 0x62,
                0x33, 0x2d, 0x33, 0x0c, 0x95, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x4e, 0x65, 0x78, 0x75, 0x73,
                0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65,
                0x6d, 0x20, 0x28, 0x4e, 0x58, 0x2d, 0x4f, 0x53, 0x29, 0x20, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61,
                0x72, 0x65, 0x0a, 0x54, 0x41, 0x43, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x3a, 0x20,
                0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x63, 0x69, 0x73, 0x63, 0x6f,
                0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x61, 0x63, 0x0a, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67,
                0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x32, 0x2d, 0x32, 0x30, 0x31, 0x32,
                0x2c, 0x20, 0x43, 0x69, 0x73, 0x63, 0x6f, 0x20, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x2c,
                0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x73,
                0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x0e, 0x04, 0x00, 0x04, 0x00, 0x04,
                0x10, 0x0c, 0x05, 0x01, 0xc0, 0xa8, 0x00, 0x3a, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x37,
                0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
                0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x08, 0x08, 0x08, 0x0a, 0x00, 0x00, 0x80, 0x00, 0x89, 0x06,
                0x00, 0x1b, 0x21, 0x08, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x32, 0x32,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xfe, 0x05, 0x00, 0x01, 0x42, 0x01, 0x01, 0xfe, 0x14,
                0x00, 0x01, 0x42, 0x02, 0x05, 0xdc, 0x05, 0xdc, 0x05, 0xdc, 0x08, 0x6e, 0x05, 0xdc, 0x05, 0xdc,
                0x05, 0xdc, 0x05, 0xdc, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x32, 0x00, 0x00
                };            
u8 g_dcbx_sample_capture_1_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_1.pcap
            0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
            0x28, 0xfe, 0x3d, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x03, 0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x64, 0x03, 0x06, 0x06, 0x00, 0x00, 0x80, 0x00, 0x00, 0x08, 0x08, 0x10,
            0x00, 0x00, 0x80, 0x00, 0xc3, 0x51, 0x01, 0x1b, 0x21, 0x02, 0xc3, 0x50, 0x01, 0x1b, 0x21, 0x04,
            0x0c, 0x58, 0x4a, 0x75, 0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,
            0x6b, 0x73, 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30,
            0x73, 0x20, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33,
            0x58, 0x35, 0x30, 0x2e, 0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65,
            0x3a, 0x20, 0x32, 0x30, 0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a,
            0x33, 0x32, 0x3a, 0x30, 0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14,
            0x08, 0x0b, 0x78, 0x65, 0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00,
            0x12, 0x0f, 0x01, 0x01, 0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00,
            0x00, 0x00, 0x00, 0xfe, 0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2,
            0x01, 0x00, 0x00, 0xfe, 0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61,
            0x75, 0x6c, 0x74, 0x00, 0x00
            };        
u8 g_dcbx_sample_capture_2_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x88, 0xcc, 0x02, 0x07,     //dcbx_sample_capture_2.pcap      
                0x04, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0, 0x04, 0x07, 0x03, 0x00, 0x07, 0x43, 0x10, 0x53, 0xd0,
                0x06, 0x02, 0x00, 0x78, 0xfe, 0x43, 0x00, 0x1b, 0x21, 0x02, 0x02, 0x0a, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x04, 0x11, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x11, 0x1f,
                0x19, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0xc0, 0x00, 0x08,
                0x08, 0x08, 0x16, 0x00, 0x00, 0xe0, 0x00, 0x89, 0x06, 0x01, 0x1b, 0x21, 0x08, 0x0c, 0xbc, 0x01,
                0x1b, 0x21, 0x08, 0x89, 0x14, 0x00, 0x1b, 0x21, 0x08, 0x00, 0x00
                };  

u8 g_ieee_pcap_buf[] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x71, 0x88, 0xcc, 0x02, 0x07,           //ieee.pcap
                0x04, 0x84, 0x18, 0x88, 0xd6, 0x39, 0x48, 0x04, 0x04, 0x07, 0x35, 0x32, 0x36, 0x06, 0x02, 0x00,
                0x28, 0xfe, 0x19, 0x00, 0x80, 0xc2, 0x09, 0x03, 0x77, 0x76, 0x77, 0x76, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x64, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x19, 0x00, 0x80,
                0xc2, 0x0a, 0x03, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x02,
                0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x0b, 0x08, 0x00, 0xfe,
                0x0b, 0x00, 0x80, 0xc2, 0x0c, 0x00, 0x24, 0xc3, 0x51, 0x44, 0xc3, 0x50, 0x0c, 0x58, 0x4a, 0x75,
                0x6e, 0x69, 0x70, 0x65, 0x72, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x2c, 0x20,
                0x49, 0x6e, 0x63, 0x2e, 0x20, 0x71, 0x66, 0x78, 0x33, 0x35, 0x30, 0x30, 0x73, 0x20, 0x2c, 0x20,
                0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x32, 0x2e, 0x33, 0x58, 0x35, 0x30, 0x2e,
                0x31, 0x20, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x64, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x32, 0x30,
                0x31, 0x33, 0x2d, 0x30, 0x33, 0x2d, 0x30, 0x35, 0x20, 0x30, 0x30, 0x3a, 0x33, 0x32, 0x3a, 0x30,
                0x36, 0x20, 0x55, 0x54, 0x43, 0x20, 0x0e, 0x04, 0x00, 0x14, 0x00, 0x14, 0x08, 0x0b, 0x78, 0x65,
                0x2d, 0x30, 0x2f, 0x30, 0x2f, 0x33, 0x38, 0x2e, 0x30, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x01, 0x01,
                0x6c, 0x1d, 0x00, 0x00, 0xfe, 0x09, 0x00, 0x12, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0xfe,
                0x06, 0x00, 0x12, 0x0f, 0x04, 0x05, 0xea, 0xfe, 0x06, 0x00, 0x80, 0xc2, 0x01, 0x00, 0x00, 0xfe,
                0x0e, 0x00, 0x80, 0xc2, 0x03, 0x00, 0x00, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x00,
                0x00
                };

typedef struct {
    u8 sync_config;
    u8 sync_config_sup;
    u8 event_class_cnt;
    u8 eventclass[0];
} pldm_event_msg_sup_rsp_dat_t;

u8 gs_buf[128] = {244};

u8 gs_sumbus_pkt0[] = {                         /* Clear Initial State 0x00 */
    0x92, 0x0f, 0x1a, 0x21,
    0x01, 0x0A, 0x08, 0xfb,
    0x02,
    0x00, 0x01, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,                   /* checksum */
    0x40                                        /* pec */
};

#pragma pack(1)

typedef struct {
	u16 entity_type;
	u16 entity_instance_num;
	u16 entity_container_id;
} pldm_entity;

typedef struct {
	u32 record_handle;
	u8 version;
	u8 type;
	u16 record_change_num;
	u16 length;
}pldm_pdr_hdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u16 sensor_id;
    pldm_entity container;
    u8 sensor_init;
    bool sensor_auxiliary_names_pdr;
    u8 base_unit;
    s8 unit_modifier;
    u8 rate_unit;
    u8 base_oem_unit_handle;
    u8 aux_unit;
    u8 aux_unit_modifier;
    u8 aux_rate_unit;
    u8 rel;
    u8 aux_oem_unit_handle;
    bool is_linear;
    u8 sensor_data_size;
    u32 resolution;
    u32 offset;
    u16 accuracy;
    u8 plus_tolerace;
    u8 minus_tolerance;
    u8 hysteresis;
    u8 supported_thresholds;
    u8 threshold_and_hysteresis_volatility;
    u32 state_transition_interval;
    u32 update_interval;
    u8 max_readable;
    u8 min_readable;
    u8 range_field_format;
    u8 range_field_support;
    u16 nominal_value;
	u16 normal_max;
	u16 normal_min;
	u16 warning_high;
	u16 warning_low;
	u16 critical_high;
	u16 critical_low;
	u16 fatal_high;
	u16 fatal_low;
} pldm_thermal_sensor_pdr;

typedef struct {
    pldm_pdr_hdr hdr;
    u16 terminus_handle;
    u8 validity;
    u8 tid;
    u16 container_id;
    u8 terminus_locator_type;
	u8 terminus_locator_value_size;
    u8 eid;
} pldm_terminus_locator_pdr;

typedef struct {
    u8 sensor_type;
    u8 composite_state;
} pldm_composite_sensor_attr;

typedef struct {
    pldm_entity container;
    u16 terminus_handle;
    u16 sensor_id;
    u8 composite_sensor_cnt;
    pldm_composite_sensor_attr sensors[3];
} pldm_somposite_state_sensor_pdr;

typedef struct {
	u16 container_id;
	u8 association_type;
	pldm_entity container;
	u8 num_children;
	pldm_entity children[3];
} pldm_pdr_entity_association;

typedef struct {
    u8 tid;
    u16 event_id;
    u32 next_data_transfer_handle;
    u8 transfer_flag;
    u8 event_class;
    u32 event_datasize;                     /* Size in byes of eventData */
    u8 *event_data;
    u32 event_data_integrity_checksum;
} pldm_poll_for_platform_event_msg_rsp_dat_t;

#pragma pack()

u8 a[] = {1,2,3,4,5,6};
u8 b[] = {1,2,3,4,5};
u8 c[] = {1,2,3,4};

u8 *data[] = {
    a,b,c
};
u8 erwei[2][2] = {
    [0] = {
        1,2
    },
    [1] = {
        1,2
    },
};

void printf_one(int a)
{
    printf("%d\n", a);
}

void test(void)
{
    int num = 1000;
    printf_one(num);
}

typedef void (*func)(void);

void ab(void)
{
    printf("hhhhhh\n");
}
#pragma pack(1)

typedef struct {
    u8 seq;
    u8 fmt;
    u16 len;
    u8 sfl_len;
    u8 *val;
} pldm_bej_sflv_t;

typedef struct {
    u8 len;         /* max len is 0xFF */
    u8 data[0];     /* LSB -> MSB */
} pldm_bej_nnint_t;

typedef struct {
    u8 format;
    u16 sequence_num;
    u16 childpoint_off;
    u16 child_cnt;
    u8 name_len;
    u16 name_off;
} pldm_redfish_dictionary_entry_t;

typedef struct {
    u8 version_tag;
    u8 dictionay_flags;
    u16 entry_cnt;  // name count
    u32 schema_version;
    u32 dictionary_size;
    pldm_redfish_dictionary_entry_t entry[0];
    // u8 name[0];
    // u8 copyright_len;
    // u8 copyright[0];
} pldm_redfish_dictionary_format_t;

typedef struct {
    u8 len;
    u8 *val;
} pldm_bej_key_t;

#pragma pack()

typedef enum {
    BEJ_SET = 0,
    BEJ_ARRAY,
    BEJ_NULL,
    BEJ_INT,
    BEJ_ENUM,
    BEJ_STR,
    BEJ_REAL,
    BEJ_BOOLEAN,
    BEJ_BYTE_STR,
    BEJ_CHOICE,
    BEJ_PROPERTY_ANNO,
    BEJ_REGISTRY_ITEM,
    BEJ_RESOURCE_LINK = 0xE,
    BEJ_RESOURCE_LINK_EXPANSION = 0xF,
} pldm_bej_fmt_t;
// static pldm_bej_sflv_t sflv = {0, 0, 0, NULL};
u8 bej_buf[] = {
    0x01, 0x00, 0x00, 0x01, 0x48, 0x01, 0x04, 0x01,
    0x21, 0x51, 0x01, 0x04, 0x25, 0x4C, 0x31, 0x30,
    0x01, 0x00, 0x10, 0x01, 0x24, 0x01, 0x02, 0x01,
    0x00, 0x00, 0x01, 0x0F, 0x01, 0x02, 0x01, 0x00,
    0x70, 0x01, 0x01, 0xFF, 0x01, 0x02, 0x40, 0x01,
    0x02, 0x01, 0x02, 0x01, 0x02, 0x00, 0x01, 0x09,
    0x01, 0x01, 0x01, 0x02, 0x40, 0x01, 0x02, 0x01,
    0x00, 0x01, 0x02, 0x50, 0x01, 0x09, 0x44, 0x75,
    0x6D, 0x6D, 0x79, 0x20, 0x49, 0x44, 0x00, 0x01,
    0x06, 0x30, 0x01, 0x01, 0x0C
};

u8 dict[] = {
    0x00, 0x00, 0x0B, 0x00, 0x00, 0xF0, 0xF0, 0xF1,
    0x12, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16,
    0x00, 0x04, 0x00, 0x0C, 0x7A, 0x00, 0x14, 0x00,
    0x00, 0x3E, 0x00, 0x01, 0x00, 0x13, 0x86, 0x00,
    0x56, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x99, 0x00, 0x74, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x16, 0x9C, 0x00, 0x34, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x16, 0xB2, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
    0xC8, 0x00, 0x46, 0x01, 0x00, 0x5C, 0x00, 0x03,
    0x00, 0x0B, 0xD7, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x09, 0xE2, 0x00, 0x50, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xEB, 0x00,
    0x50, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0xF2, 0x00, 0x44, 0x75, 0x6D, 0x6D, 0x79, 0x53,
    0x69, 0x6D, 0x70, 0x6C, 0x65, 0x00, 0x43, 0x68,
    0x69, 0x6C, 0x64, 0x41, 0x72, 0x72, 0x61, 0x79,
    0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
    0x00, 0x49, 0x64, 0x00, 0x53, 0x61, 0x6D, 0x70,
    0x6C, 0x65, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65,
    0x64, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
    0x79, 0x00, 0x53, 0x61, 0x6D, 0x70, 0x6C, 0x65,
    0x49, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50,
    0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
    0x41, 0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x42,
    0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x00, 0x4C,
    0x69, 0x6E, 0x6B, 0x53, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x00, 0x4C, 0x69, 0x6E, 0x6B, 0x44, 0x6F,
    0x77, 0x6E, 0x00, 0x4C, 0x69, 0x6E, 0x6B, 0x55,
    0x70, 0x00, 0x4E, 0x6F, 0x4C, 0x69, 0x6E, 0x6B,
    0x00, 0x18, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69,
    0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20,
    0x32, 0x30, 0x31, 0x38, 0x20, 0x44, 0x4D, 0x54,
    0x46, 0x00
};

u16 pldm_bej_get_len(u8 *buf)
{
    u16 len = 0;
    if (buf[0] == 1) {
        len = buf[1];
    } else {
        len = buf[1];
        len <<= 8;
        len |= buf[2];
    }
    return len;
}

void pldm_bej_get_sflv(u8 *buf, pldm_bej_sflv_t *sflv)
{
    if (buf == NULL) return;
    pldm_bej_nnint_t *nnint = (pldm_bej_nnint_t *)buf;
    u8 seq_len = nnint->len;        /* always 1 */
    sflv->seq = nnint->data[0];
    nnint = (pldm_bej_nnint_t *)&nnint->data[seq_len];

    sflv->fmt = nnint->len;
    nnint = (pldm_bej_nnint_t *)nnint->data;

    sflv->len = pldm_bej_get_len((u8 *)nnint);
    nnint = (pldm_bej_nnint_t *)&nnint->data[nnint->len];

    sflv->val = (u8 *)nnint;

    sflv->sfl_len = (u8 *)nnint - buf + sflv->len;
}

void pldm_bej_encode(u8 *buf, u16 len)
{

}
pldm_bej_key_t key, enum_key;
void pldm_bej_dict_search(pldm_bej_sflv_t *sflv, u8 *dict)
{
    u8 is_find = 0;
    key.val = NULL;
    pldm_redfish_dictionary_format_t *dict_ptr = (pldm_redfish_dictionary_format_t *)dict;
    for (u8 k = 0; k < dict_ptr->entry_cnt; k++) {
        u8 dict_fmt = dict_ptr->entry[k].format >> 4;
        if (dict_fmt == sflv->fmt >> 4 && dict_ptr->entry[k].sequence_num == sflv->seq >> 1) {
            key.val = &dict[dict_ptr->entry[k].name_off];
            key.len = dict_ptr->entry[k].name_len;
            for (u8 l = 0; l < key.len; l++) {
                printf("%c", key.val[l]);
            }
            printf(": ");
            is_find = 1;
            if (dict_fmt == BEJ_ENUM) {
                pldm_redfish_dictionary_entry_t *enum_ptr = (pldm_redfish_dictionary_entry_t *)&dict[dict_ptr->entry[k].childpoint_off];
                enum_ptr += sflv->val[1];
                enum_key.len = enum_ptr->name_len;
                enum_key.val = &dict[enum_ptr->name_off];
                for (u8 l = 0; l < enum_key.len; l++) {
                    printf("%c", enum_key.val[l]);
                }
            }
            break;
        }
    }
    if (!is_find) {
        printf("fmt err: ");
    }
}

void pldm_bej_val_search(pldm_bej_sflv_t *sflv)
{
    u8 fmt = sflv->fmt >> 4;
    for (u8 j = 0; j < sflv->len; j++) {
        if (fmt == BEJ_INT) {
            printf("%d", sflv->val[0]);
            break;
        } else if (fmt == BEJ_ENUM) {

        } else {
            printf("0x%x ", sflv->val[j]);
        }
    }
    printf("\n");
}

u16 pldm_bej_decode(u8 *buf)
{
    pldm_bej_sflv_t sflv = {0, 0, 0, 0, NULL};
    u8 cnt = 0;
    pldm_bej_get_sflv(buf, &sflv);
    pldm_bej_dict_search(&sflv, dict);
    u8 fmt = sflv.fmt >> 4;
    if (fmt == BEJ_SET || fmt == BEJ_ARRAY) {     /* 0 : set, 1 : array */
        cnt = sflv.val[1];
        sflv.val = &(sflv.val[2]);
        printf("\n");
    }
    // printf("seq : 0x%x, fmt : 0x%x, len : 0x%x, val : %x\n", sflv.seq, fmt, sflv.len, sflv.val[0]);
    for (u8 i = 0; i < cnt; i++) {
        u16 len = pldm_bej_decode(sflv.val);
        sflv.val += len;
    }
    if (!cnt) pldm_bej_val_search(&sflv);
    return sflv.sfl_len;
}

int main(int argc, char * argv [])
{
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // pldm_event_msg_sup_rsp_dat_t *aa = (pldm_event_msg_sup_rsp_dat_t *)gs_buf;
    // u32 c = (u32)gs_buf;
    // u32 *a = (u32 *)(c);
    // u8 b[8] = {0};

    // ((u32 *)b)[0] = 0x12345678;
    // u8 pec = crc16_i2c_smbus(0, gs_sumbus_pkt0, gs_sumbus_pkt0[2] + 3);
    // pldm_poll_for_platform_event_msg_rsp_dat_t *a = NULL;
    // printf("0x%x\n", pec);
    // printf("%x\n", *((u32 *)(&b[0])));
    // DCBX_ANALYZE(g_dcbx_sample_capture_2_pcap_buf);
    // u8 present_state = 10;
    // u8 *a = &present_state;
    // printf("%d", a[0]);
    // printf("%d\n", test());
    // unsigned char in[] = "hello world";
	// unsigned char buff[32];//必须带unsigned ,sha256消息摘要输出为256位,即32字节
	// memset(buff,0,32);
	// puts("start sha256 hash \n");
	// sha256(in,strlen(in),buff);
	// printf("\nThe sha256 hash is :\n");
    // 	for(int i=0;i<32;i++)
	// {
 
	// 	printf("%02x",buff[i]);	
	// }
	// puts("\n end sha256 hash \n");
    // rsa_test();
    // u8 xzxz[] = {0x1c, 0x1c, 0x1c, 0x1c};
    // printf("%x", crc32_pldm(xzxz, 4));
    // u32 notify_buf[] = {
    //     0xa7006003, \
    //     0x00000000, \
    //     0x0092e004, \
    //     0x1000017f, \
    //     0xb41a0000, \
    //     0xc8080001, \
    //     0x000d8000, \
    //     0x00000000
    // };
    // mctp_hdr_t *mctp_hdr = (mctp_hdr_t *)&notify_buf[5];
    // printf("src_eid : 0x%02x\n", mctp_hdr->dest_eid);
    printf("total len : %d\n", pldm_bej_decode(bej_buf));
	return 0;
}



